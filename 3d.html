<html>
  <head>
    <title>citycanvas</title>
  </head>

  <body>
    <canvas id="citytexture" style="display:none;"></canvas>

    <script type="text/javascript" src="underscore-min.js"></script>
    <script type="text/javascript" src="city.js"></script>
    <script type="text/javascript" src="three.js"></script>
    <script>
      var useCanvasRenderer = false;
      var camera, scene, crenderer, wrenderer, material, controls;

      init();
      animate();

      function black(side) {
        return new THREE.MeshBasicMaterial({ color: 0x000000 });
      }

      function imageTexture(canvas) {
        return new THREE.MeshBasicMaterial({
          map: new THREE.Texture(canvas)
        });
      }

      var building_texture;
      function building_cube(w, h) {
        return new THREE.MeshBasicMaterial({ color: 0xFF0000, wireframe: false });
        if (!building_texture) {
          building_texture = [];
          for (var i = 0; i < 6; i++) {
            building_texture[i] = i == 2 || i == 3
            ? black(w) : imageTexture(cityTexture(w, h));
          }
        }
        return building_texture;
      }

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          40, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.y = 400;
        camera.position.z = 2000;

        scene.add(camera);
        
        controls = new THREE.TrackballControls(camera);

				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

        var w_max = 256;
        var h_max = 512;
        var padding = 80;
        var buildings_per_side = 11;
        var building_offset = Math.floor(buildings_per_side / 2);
        for (var i = 0; i < buildings_per_side; i++) {
          for (var j = 0; j < buildings_per_side; j++) {
            if (Math.random() < .15) {
              continue;
            }

            var w = w_max;
            var h = (Math.random() * .9 + .1) * h_max;
            if (Math.random() < .05) {
              h += h_max;
            }
            var geometry =
              new THREE.CubeGeometry(w, h, w, 1, 1, 1, building_cube(w, h));

            var mesh = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial());
            mesh.position.set(
              (w + padding) * (i - building_offset),
              (h_max - h) / -2,
              (w + padding) * (j - building_offset));
            mesh.updateMatrix();
            mesh.matrixAutoUpdate = false;

            scene.add(mesh);
          }
        }

        var plane_side = (w_max + padding) * buildings_per_side + padding;
        var plane = new THREE.Mesh(
          new THREE.PlaneGeometry(plane_side, plane_side), black());
        plane.rotation.x = -Math.PI/2;
				plane.position.y = -h_max / 2;
        scene.add(plane);

        crenderer = {render: function(a, b) {}};
        wrenderer = {render: function(a, b) {}};

        if (useCanvasRenderer) {
          crenderer = new THREE.CanvasRenderer();
          crenderer.setSize( window.innerWidth, window.innerHeight );
          document.body.appendChild(crenderer.domElement);
        } else {
          wrenderer = new THREE.WebGLRenderer();
          wrenderer.setSize( window.innerWidth, window.innerHeight );
          document.body.appendChild(wrenderer.domElement);
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        render();
      }

      function render() {
        controls.update();
        crenderer.render(scene, camera);
        wrenderer.render(scene, camera);
      }

    </script>
  </body>
</html>
